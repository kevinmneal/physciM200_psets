---
title: "Variable selection for species distribution modeling: an example with the western spadefoot toad"
author: "Kevin Neal"
date: "June 12, 2015"
output: 
  html_document:
    fig_caption: yes
    fig_width: 10
    fig_height: 8
    
---
```{r global_options, include=FALSE}
knitr::opts_chunk$set(warning=FALSE, message=FALSE)
```

```{r init, echo=F, include=F}
require(minerva)
require(infotheo)
require(corrplot)
require(dismo)
require(raster)
#require(glmnet)

setwd("C:/Users/Kevin/Google Drive/UCLA Courses or Lab meetings etc/PhysciM200/physciM200_psets")
load("C:/Users/Kevin/Google Drive/UCLA Courses or Lab meetings etc/PhysciM200/physciM200_psets/PSM200finalproj.RData") # loads the workspace so knitr doesn't have to re-evaluate everything...

par(mfrow=c(1,1))
```

## INTRODUCTION  

## Spadefoot toad  
- _Spea hammondii_ - western spadefoot toad  
![Spea hammondii](http://i.imgur.com/PsRfF6F.jpg?1)


***

## Loading the spadefoot toad presence and absence point data:  

```{r loading points, eval=F}
# using spea and bioclim variables
spea.ll <- read.csv("speaLatLonBioclim.csv") # dataframe generated by extracting bioclim variable values at the latlon coordinates
spea.ll <- spea.ll[-1]
spea <- spea.ll[-c(1:2)] # creates spea which is ONLY bioclim variables, no latlon

colnames(spea.ll)[1] <- "lon" # simplifying column names
colnames(spea.ll)[2] <- "lat"
spea2 <- spea

present <- rep(1, nrow(spea))
spea2[,20] <- present
colnames(spea2)[20] <- "pres"
#summary(spea)
#corrplot(cor(spea, method="spearman"))
#pairs(spea)

### "absence" points (sampled from random background points on same grid as presence points, using chess="black" while presence points sampled from chess="white")

absent.ll <- read.csv("speaabsentLatLonBioclim.csv")
absent.ll <- absent.ll[-1]
absent <- absent.ll[,-c(1:2)] # creates dataframe of ONLY bioclim variables, no latlon  
colnames(absent.ll)[1] <- "lon" # simplifying column names
colnames(absent.ll)[2] <- "lat"
absent2 <- absent

absences <- rep(0, nrow(absent))
absent2[,20] <- absences
colnames(absent2)[20] <- "pres"

allpts <- rbind(spea2, absent2)
hammy <- allpts # hammy refers to hammondii. This is the dataframe with all the presence AND absence points AND bioclim values. No latlon.
hammy.ll <- cbind(hammy, rbind(spea.ll[,c(1:2)], absent.ll[,c(1:2)])) # the dataframe INCLUDING latlon. Probably won't need for now.

spea.llonly <- spea.ll[,c(1:2)]
absent.llonly <- absent.ll[,c(1:2)]


```


***
__The nineteen bioclim layers are:__  
* BIO1 = Annual Mean Temperature  
* BIO2 = Mean Diurnal Range (Mean of monthly (max temp - min temp))  
* BIO3 = Isothermality (BIO2/BIO7) (* 100)  
* BIO4 = Temperature Seasonality (standard deviation *100)  
* BIO5 = Max Temperature of Warmest Month  
* BIO6 = Min Temperature of Coldest Month  
* BIO7 = Temperature Annual Range (BIO5-BIO6)  
* BIO8 = Mean Temperature of Wettest Quarter  
* BIO9 = Mean Temperature of Driest Quarter  
* BIO10 = Mean Temperature of Warmest Quarter  
* BIO11 = Mean Temperature of Coldest Quarter  
* BIO12 = Annual Precipitation  
* BIO13 = Precipitation of Wettest Month  
* BIO14 = Precipitation of Driest Month  
* BIO15 = Precipitation Seasonality (Coefficient of Variation)  
* BIO16 = Precipitation of Wettest Quarter  
* BIO17 = Precipitation of Driest Quarter  
* BIO18 = Precipitation of Warmest Quarter  
* BIO19 = Precipitation of Coldest Quarter  

***

## Correlation plots using MIC and Spearman correlation:  

```{r corrplot figures, results="hide"}

pairs(hammy, cex=0.4, pch=20, gap=0.3)

par(mfrow=c(1,1))
corrplotMIC <- corrplot(mine(hammy)$MIC, main="MIC")
corrplotSpear <- corrplot(cor(hammy, method="spearman", use="pairwise.complete.obs"), main="spearman")
```

### In the corrplots, notice the strong correlations between several variable pairs. In the optimized models, it is unlikely that both of a highly correlated pair will be included because after including one, the second will contribute little to no new information to the model.  


***

## Mutual information variable selection (sensu Ivannikova et al.) with forward steps:  

```{r mutual information variable selection with forward steps, eval=F}

# corrplot(hammy.mutinfo/max(hammy.mutinfo)) # corrplot requires values between -1 and 1. I only did this to see how its patterns compare with using the mine() function in minerva

hammy.mutinfo <- mutinformation(discretize(hammy)) # bio1 has highest mutual info, i.e. strongest correlation with presence
hammy.mutinfo[,20]

#hammybc <- hammy[,-20]
#mutinformation(discretize(hammybc), discretize(hammy[,20])) # MI = 0.631 including all variables

# mutinformation(cbind(discretize(hammy[,1]), discretize(hammy[,2])), discretize(hammy[,20], nbins=2)) # if here for example we had chosen bio2 as our X1, we add each other bioclim to it to test the information gained. The variable that leads to the highest gain is X2. Then do the same to find X3, and so on. Do this until the information goes DOWN!!! If it never goes down, then the model with all 19 variables is the best...
# this example is still using dummy-absences, though. Get "true"" pseudoabsences AND add more presences by doing smarter spatial sampling... though this is a whole can of worms... 

# I can apply bootstraps to every step here... hmm then get confidence intervals on the MI of every added variable? One with highest median moves on?

# mutin1 accomplishes the same thing as just running mutinformation(discretize(hammy))
mutin1 <- rep(NA, 19)
for (i in 1:19){
  mutin1[i] <- mutinformation(discretize(hammy[,i]), discretize(hammy[,20]))
}
mutin1
#rank(mutin1) # bio1 by itself has most mutual information with presence, so bio1 becomes X1. MI = 0.2386



mutin2 <- rep(NA, 19)
for (i in 1:19){
  mutin2[i] <- mutinformation(cbind(discretize(hammy[,1]), discretize(hammy[,i])), discretize(hammy[,20]))
}

mutin2 # bio12 increases the information the most, so bio12 becomes X2. MI = 0.3576


## Then I suppose, compare the third most-informative variable (X3) determined from permuted medians to the one calculated with ALL the points.
## Here: permuted best X3 is bio2
mutin3 <- rep(NA, 19)
for(i in 1:19){
    mutin3[i] <- mutinformation(cbind(discretize(hammy[,1]), discretize(hammy[,12]), discretize(hammy[,i])), discretize(hammy[,20]))
  }
mutin
rank(mutin) # Using all the points, the best X3 is bio2; model MI(3) = 0.49495: bio1, bio12, bio2

## Let's just continue using all the points for now...

### Determining X4:
mutin4 <- rep(NA, 19)
for(i in 1:19){
    mutin4[i] <- mutinformation(cbind(discretize(hammy[,1]), 
                                      discretize(hammy[,12]), 
                                      discretize(hammy[,2]),
                                      discretize(hammy[,i])), 
                                discretize(hammy[,20]))
  }
mutin4 
rank(mutin4) # bio17 is X4; MI = 0.5748


### Determining X5:
mutin5 <- rep(NA, 19)
for(i in 1:19){
    mutin5[i] <- mutinformation(cbind(discretize(hammy[,1]), 
                                      discretize(hammy[,12]), 
                                      discretize(hammy[,2]),
                                      discretize(hammy[,17]),
                                      discretize(hammy[,i])), 
                                discretize(hammy[,20]))
  }
mutin5 
rank(mutin5) # bio4 is X5; MI = 0.6030



mutin6 <- rep(NA, 19)
for(i in 1:19){
    mutin6[i] <- mutinformation(cbind(discretize(hammy[,1]), 
                                      discretize(hammy[,12]), 
                                      discretize(hammy[,2]),
                                      discretize(hammy[,17]),
                                      discretize(hammy[,4]),
                                      discretize(hammy[,i])), 
                                discretize(hammy[,20]))
  }
mutin6 
rank(mutin6) # bio15 and bio16 are tied for X6; MI = 0.6155... maybe bootstrap to pick one??

mutin6boot <- matrix(nrow=1000, ncol=19)
for(j in 1:1000) {
  hamboot <- rbind(hammy[sample(nrow(hammy[hammy$pres==1,]), 88, replace=F),], 
                   hammy[sample(nrow(hammy[hammy$pres==0,]), 88, replace=F),])
  mutin <- rep(NA, 19)
  for(i in 1:19){
    mutin[i] <- mutinformation(cbind(discretize(hamboot[,1]), 
                                      discretize(hamboot[,12]), 
                                      discretize(hamboot[,2]),
                                      discretize(hamboot[,17]),
                                      discretize(hamboot[,4]),
                                      discretize(hamboot[,i])), 
                                discretize(hamboot[,20]))
  }
  mutin6boot[j,] <- mutin
}
mutin6CI <- apply(mutin6boot, 2, medianCI)
mutin6CI # well this didn't help... bio10 has the highest median here... could this be more informative than using all the points?...
rank(mutin6CI[1,]) # but then these results become incomparable to the other runs! fuuuuuck. So skip bootstrapping for this!! just pick one. 15 or 16. Fuck!!! I'm gonna go with 15 because Maxent put it much higher than 16...


mutin7 <- rep(NA, 19)
for(i in 1:19){
    mutin7[i] <- mutinformation(cbind(discretize(hammy[,1]), 
                                      discretize(hammy[,12]), 
                                      discretize(hammy[,2]),
                                      discretize(hammy[,17]),
                                      discretize(hammy[,4]),
                                      discretize(hammy[,15]),
                                      discretize(hammy[,i])), 
                                discretize(hammy[,20]))
  }
mutin7
rank(mutin7) # bio16; MI = 0.626



mutin8 <- rep(NA, 19)
for(i in 1:19){
    mutin8[i] <- mutinformation(cbind(discretize(hammy[,1]), 
                                      discretize(hammy[,12]), 
                                      discretize(hammy[,2]),
                                      discretize(hammy[,17]),
                                      discretize(hammy[,4]),
                                      discretize(hammy[,15]),
                                      discretize(hammy[,16]),
                                      discretize(hammy[,i])), 
                                discretize(hammy[,20]))
  }
mutin8
rank(mutin8) # tie: bio11 and bio18; MI = 0.6313. I'll go with bio18 because maxent suggests it is actually the most important variable



mutin9 <- rep(NA, 19)
for(i in 1:19){
    mutin9[i] <- mutinformation(cbind(discretize(hammy[,1]), 
                                      discretize(hammy[,12]), 
                                      discretize(hammy[,2]),
                                      discretize(hammy[,17]),
                                      discretize(hammy[,4]),
                                      discretize(hammy[,15]),
                                      discretize(hammy[,16]),
                                      discretize(hammy[,18]),
                                      discretize(hammy[,i])), 
                                discretize(hammy[,20]))
  }
mutin9
rank(mutin9) # no additional information... so the current model should be the best(?)/most parsimonious, according to MI

# best model using MI: pres ~ bio1, bio2, bio4, bio12, bio15, bio16, bio17, bio18
# This model has as much information as the model with all 19 variables!
```

### Using mutual information, I identified eight predictors that have as much information as all nineteen! (MI = 0.631 eith these eight and remains at 0.631 with the addition of any other predictors)    
### The chosen predictors differ from those chosen by step(), interestingly (evaluated below).  




```{r code for generating the random background points as test points or nevermind just use the raster prediction, eval=F, include=F}
circ <- circles(hammy.ll, d=300000, lonlat=TRUE) #creates circles of 100km radius around presence points; will draw pseudoabsences from these buffers
discirc <- gUnaryUnion(circ@polygons) #dissolve circle features into one feature
circ2 <- spTransform(discirc, CRS("+proj=longlat +datum=WGS84")) #changes CRS to match that of speaspdf
smallcirc <- circles(speaspdf, d=10000, lonlat=TRUE)
dissmallcirc <- gUnaryUnion(smallcirc@polygons)
dissmallcirc2 <- spTransform(dissmallcirc, CRS("+proj=longlat +datum=WGS84"))
circ3 <- erase(circ2, dissmallcirc2) #removes circles of radius disssmallcirc from discirc2 polygons
#sample pseudoabsence points from discirc3
#circrast <- rasterize(circ2, r) #must convert to raster before you can use another raster as a mask
#the point of this is to trim the layer at the coast so that there are no pseudoabsences in the ocean
#maskedcirc <- mask(circrast, r)
plot(maskedcirc)
plot(circ3)
points(speasel)

# the background points vary too much? constrain the area to a radius around presence points. 
## POST-EDIT: Don't constrain it next time!!! Sample from across the full landscape.
b1 <- bclim2.5Shamnarrow[[1]]
plot(b1)
rr <- mask(b1, circ3)
plot(rr)
absent3 <- randomPoints(rr, 1000, speasel) #pulls random background points from extent of raster
points(absent3)

res(r) <- 0.1
r1 <- r
res(r1) <- 0.5

absent4 <- gridSample(absent3, r, n=1, chess="black") #produces subsample of n=1 point from each raster grid; this will be occurrence data input
absent4 <- gridSample(absent4, r1, n=1)
absent5 <- absent4[sample(nrow(absent4), 176),] # sample random rows. Double the number of presence points.

pp <- rasterToPolygons(rr)
plot(p1, border='gray')
points(speasel, cex=1, col='red', pch='x')
points(absent5, col="blue")

absent.variables <- extract(bclim2.5Shamnarrow, absent5)
speaabsent.latlon.bio <- cbind(coordinates(absent5), absent.variables)
write.csv(speaabsent.latlon.bio, file="speaabsentLatLonBioclim.csv")
# I did this with the presence points as well, but in a different R script file


```

***

## GLM models:  

```{r putting the variable selection methods in one place, eval=F}
hammy.glm <- glm(pres ~ bio1+bio2+bio3+bio4+bio5+bio6+bio7+bio8+bio9+bio10+bio11+bio12+bio13+bio14+bio15+bio16+bio17+bio18+bio19, family=binomial(link = "logit"), data=hammy)
summary(hammy.glm)
step(hammy.glm, direction="backward")

# using step() with glm, get lowest AIC with pres ~ bio1 + bio4 + bio9 + bio14 + bio15 + bio17 + bio18 + bio19
hammy.glm.step <- glm(pres ~ bio1 + bio4 + bio9 + bio14 + bio15 + bio17 + bio18 + bio19, family=binomial(link = "logit"), data=hammy)
summary(hammy.glm.step)

# best model using MI: pres ~ bio1, bio2, bio4, bio12, bio15, bio16, bio17, bio18
# as an aside: the order you put variables into the glm with + doesn't matter...
hammy.glm.mi <- glm(pres ~ bio1 + bio12 + bio2 + bio17 + bio4 + bio15 + bio16 + bio18, family=binomial(link = "logit"), data=hammy)
summary(hammy.glm.mi)


```

***

## Bootstrap functions:  
### These functions bootstrap resample from the presence points and from the absence points separately (so each iteration keeps the same number of presence and absence points), and the model is re-run with the resampled datapoints. The output is the map of the median probability of all bootstrapped predictions:  

```{r bootstrap functions}
## bootstrapped model

bootPredict <- function(rasterbrick, model, present=spea2, absent=absent2, reps=10){ # will use spea2 and absent2
  bootpreds <- replicate(reps, {
    pp <- sample(nrow(present), replace=T)
    aa <- sample(nrow(absent), replace=T)
    bootpres <- present[pp,]
    bootabsent <- absent[aa,]
    bootallpts <- rbind(bootpres, bootabsent) # combines bootstrapped present and absence points together into one dataframe
    newmodel <- update(model, data=bootallpts)
    newpredict <- predict(rasterbrick, newmodel, type="response")
    
  })
  medianpred <- calc(brick(bootpreds), fun=median)
  madpred <- calc(brick(bootpreds), fun=mad)
  #confintpred <- calc(brick(bootpreds), fun=quantile, probs=c(0.025, 0.975))
  invisible(stack(medianpred, madpred))
}

# bootstrapped NHST
bootPredict.nh <- function(rasterbrick, model, locs=hammy, reps=10){ # will use spea2 and absent2
  bootpreds.nh <- replicate(reps, {
    bootallpts <- apply(locs, 2, sample, replace=F) # shuffles data within columns for doing NHST
    bootallpts <- data.frame(bootallpts)
    #colnames(bootallpts) <- colnames(locs)
    newmodel <- update(model, data=bootallpts)
    newpredict <- predict(rasterbrick, newmodel, type="response")
    
  })
  medianpred.nh <- calc(brick(bootpreds.nh), fun=median)
  madpred.nh <- calc(brick(bootpreds.nh), fun=mad)
  #confintpred <- calc(brick(bootpreds), fun=quantile, probs=c(0.025, 0.975))
  invisible(stack(medianpred.nh, madpred.nh))
}
```

***

## Model predictions:  
### the package "raster" allows for explicit spatial prediction using the values in the variable rasters/maps  

```{r predictions, eval=F}

# ?predict (use it as implemented in raster package, not dismo)
# bootstrap the predictions and plot the median

bclimRaster <- brick("C:/Users/Kevin/Google Drive/UCLA Courses or Lab meetings etc/EEB 234/Final Project files/bioclim2.5/ShamnarrowBC_2.5.grd") # this contains the raster maps of all 19 climate variables

bclimRaster.mi <- bclimRaster[[c(1,2,4,12,15,16,17,18)]] #bio1, bio2, bio4, bio12, bio15, bio16, bio17, bio18
bclimRaster.glm.step <- bclimRaster[[c(1,4,9,14,15,17,18,19)]] #bio1 + bio4 + bio9 + bio14 + bio15 + bio17 + bio18 + bio19

hammyPredict.glm.step <- predict(bclimRaster.glm.step, hammy.glm.step, type="response") # type="response" gives probabilities on logit scale using the response variable, i.e. presence/absence
hammyPredict.mi <- predict(bclimRaster.mi, hammy.glm.mi, type="response")
hammyPredict.full <- predict(bclimRaster, hammy.glm, type="response")


# bootstrap the models and take the median over all predictions. Print MAD as well.
hammyPredict.full.boot <- bootPredict(bclimRaster, hammy.glm, reps=100)
hammyPredict.full.nh <- bootPredict.nh(bclimRaster, hammy.glm, reps=100)

hammyPredict.glm.step.boot <- bootPredict(bclimRaster.glm.step, hammy.glm.step, reps=100)
hammyPredict.glm.step.nh <- bootPredict.nh(bclimRaster.glm.step, hammy.glm.step, reps=100)

hammyPredict.mi.boot <- bootPredict(bclimRaster.mi, hammy.glm.mi, reps=100)
hammyPredict.mi.nh <- bootPredict.nh(bclimRaster.mi, hammy.glm.mi, reps=100)

```

***
***

## The following maps show __probability of occurrence__ projected across the study area. Because absences/pseudoabsences were not sampled from the entire study area, the model often stumbles in areas of novel climate (see e.g. lower right in all maps).  

## GLM model with all 19 predictors:  

```{r plotting full GLM model, echo=F}
par(mfrow=c(1,2))
plot(hammyPredict.full, col=heat.colors(50), main="probs, 19var GLM")
points(spea.llonly, pch="+")
points(absent.llonly, pch="-")
legend("topright", legend=c("+  pres", "-  abs"))
plot(hammyPredict.full.boot[[1]], col=heat.colors(50), main="bootmedian, 19var GLM") # explain how you bootstrapped
points(spea.llonly, pch="+")
points(absent.llonly, pch="-")
legend("topright", legend=c("+  pres", "-  abs"))
# plot(hammyPredict.full.boot[[2]], col=heat.colors(50), main="bootMAD, 19var GLM") 
# points(spea.llonly, pch="+")
# points(absent.llonly, pch="-")
# legend("topright", legend=c("+  pres", "-  abs"))

par(mfrow=c(1,2))
plot(hammyPredict.mi.boot[[1]], col=heat.colors(50), main="bootmedian, 19var GLM") 
points(spea.llonly, pch="+")
points(absent.llonly, pch="-")
legend("topright", legend=c("+  pres", "-  abs"))
plot(hammyPredict.full.nh[[1]], col=heat.colors(50), main="bootmedian, 19var GLM, null") 
points(spea.llonly, pch="+")
points(absent.llonly, pch="-")
legend("topright", legend=c("+  pres", "-  abs"))
```

***

## GLM model with stepwise-determined predictors:  

```{r plotting step GLM model, echo=F }
par(mfrow=c(1,2))
plot(hammyPredict.glm.step, col=heat.colors(50), main="probs, step GLM")
points(spea.llonly, pch="+")
points(absent.llonly, pch="-")
legend("topright", legend=c("+  pres", "-  abs"))
plot(hammyPredict.glm.step.boot[[1]], col=heat.colors(50), main="bootmedian, step GLM") # explain how you bootstrapped
points(spea.llonly, pch="+")
points(absent.llonly, pch="-")
legend("topright", legend=c("+  pres", "-  abs"))
# plot(hammyPredict.glm.step.boot[[2]], col=heat.colors(50), main="bootMAD, step GLM") 
# points(spea.llonly, pch="+")
# points(absent.llonly, pch="-")
# legend("topright", legend=c("+  pres", "-  abs"))

par(mfrow=c(1,2))
plot(hammyPredict.mi.boot[[1]], col=heat.colors(50), main="bootmedian, MI best GLM") 
points(spea.llonly, pch="+")
points(absent.llonly, pch="-")
legend("topright", legend=c("+  pres", "-  abs"))
plot(hammyPredict.mi.nh[[1]], col=heat.colors(50), main="bootmedian, MI best GLM, null") 
points(spea.llonly, pch="+")
points(absent.llonly, pch="-")
legend("topright", legend=c("+  pres", "-  abs"))
```

***

## GLM model with MI-selected predictors:   

```{r plotting MI GLM model, echo=F }
par(mfrow=c(1,2))
plot(hammyPredict.mi, col=heat.colors(50), main="probs, MI best GLM")
points(spea.llonly, pch="+")
points(absent.llonly, pch="-")
legend("topright", legend=c("+  pres", "-  abs"))
plot(hammyPredict.mi.boot[[1]], col=heat.colors(50), main="bootmedian, MI best GLM") 
points(spea.llonly, pch="+")
points(absent.llonly, pch="-")
legend("topright", legend=c("+  pres", "-  abs"))
# plot(hammyPredict.mi.boot[[2]], col=heat.colors(50), main="bootMAD, MI best GLM") 
# points(spea.llonly, pch="+")
# points(absent.llonly, pch="-")
# legend("topright", legend=c("+  pres", "-  abs"))

par(mfrow=c(1,2))
plot(hammyPredict.mi.boot[[1]], col=heat.colors(50), main="bootmedian, MI best GLM") 
points(spea.llonly, pch="+")
points(absent.llonly, pch="-")
legend("topright", legend=c("+  pres", "-  abs"))
plot(hammyPredict.mi.nh[[1]], col=heat.colors(50), main="bootmedian, MI best GLM, null") 
points(spea.llonly, pch="+")
points(absent.llonly, pch="-")
legend("topright", legend=c("+  pres", "-  abs"))
#plot(hammyPredict.mi.nh[[2]], col=heat.colors(50), main="bootMAD, MI best GLM, null") 
#points(spea.llonly, pch="+")
#points(absent.llonly, pch="-")
#legend("topright", legend=c("+  pres", "-  abs"))

```


***

## Model probabilities of occurrence at the data used to generate the model itself. Index 1-88 are true presences (actual prob=1) and 89+ are pseudoabsences (actual prob=0): 

```{r model evaluation at input localities, echo=F}
par(mfrow=c(1,3))
plot(predict(hammy.glm, type="response"), main="full GLM predictions at inputs") # these are the model's predictions of the actual datapoints (x is probability of presence, x is index of the datapoints. 1-88 are true presences; 89+ are pseudoabsences... interesting.)
plot(predict(hammy.glm.step, type="response"), main="step GLM pred at inputs")
plot(predict(hammy.glm.mi, type="response"), main="MI GLM pred at inputs")
```  

***

## Area under ROC curve for all three models:  

```{r AUC evaluation, echo=F}
par(mfrow=c(1,3))
# ee <- evaluate(spea2, absent2, hammy.glm.mi)
# 
# plot(ee, "ROC")
# plot(ee, "TPR")
# boxplot(ee)
# density(ee)

e.full <- evaluate(spea2, absent2, hammy.glm)

e.mi <- evaluate(spea2, absent2, hammy.glm.mi)

e.step <- evaluate(spea2, absent2, hammy.glm.step)

plot(e.full, "ROC", sub="full GLM AUC") # AUC = 0.927
title(main="full GLM", line=3)
plot(e.step, "ROC", sub="step GLM AUC") # AUC = 0.923
title(main="step GLM", line=3)
plot(e.mi, "ROC", sub="MI GLM AUC") # AUC = 0.902
title(main="MI GLM", line=3)

```

### Receiver operating characteristic curves of the three models examined. The area under these curves is assumed to be a measure of model performance, with higher AUC indicating a better model. AUC are only comparable across models using same presence and absence points and the same areal extent. With the highest AUC of 0.927, the GLM model with all 19 bioclim variables performs the best, though this may come at a cost of generalizability to novel climate spaces.  

***

```{r model comparison, eval=F, include=F}
## Are these models actually significantly different from one another?
# these only make sense if the models are nested, so can only compare the full 19var model with the other two
anova(hammy.glm.mi, hammy.glm, test="Cp") # Cp gives AIC. full glm is better.
anova(hammy.glm.mi, hammy.glm, test="Chisq") # significant p-value (0.0012)
anova(hammy.glm.step, hammy.glm, test="Cp") # Cp gives AIC. glm.step is better.
anova(hammy.glm.step, hammy.glm, test="Chisq") # non-significant p-value (0.938)

```

